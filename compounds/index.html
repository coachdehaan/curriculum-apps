<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chem-Name Builder v3</title>
  <style>
    * { box-sizing: border-box; font-family: Arial, sans-serif; }
    body {
      margin: 0;
      padding: 8px;
      display: flex;
      gap: 8px;
      height: 100vh;
    }
    #left, #right {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    h2 {
      margin: 2px 0;
      font-size: 15px;
      font-weight: bold;
    }
    .panel {
      border: 1px solid #444;
      padding: 6px;
      border-radius: 3px;
    }

    /* Periodic table */
    #periodic-table {
      display: grid;
      grid-template-columns: repeat(18, 1fr);
      grid-auto-rows: 30px;
      gap: 2px;
      font-size: 10px;
    }
    .element {
      border: 1px solid #999;
      border-radius: 2px;
      text-align: center;
      line-height: 1.1;
      padding-top: 2px;
      cursor: pointer;
      user-select: none;
    }
    .element.metal { background-color: #f4f4ff; }
    .element.nonmetal { background-color: #e9ffe9; }
    .element.metalloid { background-color: #fff7df; }
    .element.inactive {
      border-style: dotted;
      color: #bbb;
      cursor: default;
      background-color: #f9f9f9;
    }
    .element.selected {
      outline: 2px solid #000;
    }

    /* Polyatomic buttons */
    #poly-list {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      font-size: 10px;
    }
    .poly-btn {
      border: 1px solid #777;
      border-radius: 3px;
      padding: 2px 4px;
      cursor: pointer;
      background-color: #fff9e6;
      user-select: none;
    }
    .poly-btn:hover {
      border-color: #000;
    }

    /* Builder */
    #builder {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .slots-row {
      display: flex;
      gap: 6px;
    }
    .slot {
      flex: 1;
      border: 1px solid #999;
      padding: 4px;
      border-radius: 3px;
      font-size: 11px;
    }
    .slot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 3px;
    }
    .slot-body {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .slot-symbol {
      font-size: 18px;
      font-weight: bold;
    }
    .slot-meta {
      font-size: 11px;
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 3px;
      font-size: 11px;
    }
    .controls input[type="number"] {
      width: 32px;
    }

    /* Results */
    #results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    #results-table td {
      border: 1px solid #ccc;
      padding: 3px 4px;
      vertical-align: top;
    }
    #formula-display {
      font-size: 17px;
      font-weight: bold;
    }
    #name-display {
      font-size: 15px;
      font-weight: bold;
    }
    #bond-summary {
      font-size: 11px;
      white-space: pre-line;
    }
    #explanation {
      font-size: 11px;
      white-space: pre-line;
    }
    .badge {
      display: inline-block;
      padding: 1px 4px;
      border-radius: 3px;
      border: 1px solid #333;
      font-size: 10px;
      margin-right: 4px;
    }
  </style>
</head>
<body>
  <div id="left">
    <div class="panel">
      <h2>Interactive Periodic Table</h2>
      <div id="periodic-table"></div>
    </div>
    <div class="panel">
      <h2>Common Polyatomic Ions</h2>
      <div id="poly-list"></div>
    </div>
    <div class="panel" style="font-size: 11px;">
      <strong>Use in class:</strong>
      <ol style="margin: 4px 0 0 16px; padding-left: 8px;">
        <li>Choose active slot (1 or 2).</li>
        <li>Click an element <em>or</em> polyatomic ion.</li>
        <li>If both are elements:
          <ul style="margin: 0 0 0 14px; padding-left: 6px;">
            <li>Metal + nonmetal → ionic naming (charges auto-balanced).</li>
            <li>Nonmetal + nonmetal → covalent naming (use subscripts n₁, n₂).</li>
          </ul>
        </li>
        <li>If any polyatomic ion is used → ionic naming with polyatomics.</li>
      </ol>
    </div>
  </div>

  <div id="right">
    <div class="panel" id="builder">
      <h2>Species Slots (1 & 2)</h2>
      <div class="slots-row">
        <div class="slot" id="slot1">
          <div class="slot-header">
            <span><input type="radio" name="activeSlot" value="1" checked /> Slot 1</span>
            <button type="button" onclick="clearSlot(1)" style="font-size: 10px;">Clear</button>
          </div>
          <div class="slot-body">
            <div>
              <div class="slot-symbol" id="slot1-symbol">–</div>
              <div class="slot-meta" id="slot1-name">No species</div>
            </div>
            <div class="controls">
              <span>n₁:</span>
              <input type="number" id="slot1-count" min="1" max="10" value="1" onchange="updateAll()" />
            </div>
          </div>
        </div>
        <div class="slot" id="slot2">
          <div class="slot-header">
            <span><input type="radio" name="activeSlot" value="2" /> Slot 2</span>
            <button type="button" onclick="clearSlot(2)" style="font-size: 10px;">Clear</button>
          </div>
          <div class="slot-body">
            <div>
              <div class="slot-symbol" id="slot2-symbol">–</div>
              <div class="slot-meta" id="slot2-name">No species</div>
            </div>
            <div class="controls">
              <span>n₂:</span>
              <input type="number" id="slot2-count" min="1" max="10" value="1" onchange="updateAll()" />
            </div>
          </div>
        </div>
      </div>
      <button type="button" onclick="swapSlots()" style="margin-top: 4px; font-size: 10px;">Swap 1 ↔ 2</button>
    </div>

    <div class="panel">
      <h2>Results</h2>
      <table id="results-table">
        <tr>
          <td style="width: 32%;">Formula</td>
          <td><span id="formula-display">–</span></td>
        </tr>
        <tr>
          <td>Name</td>
          <td><span id="name-display">–</span></td>
        </tr>
        <tr>
          <td>Bond & EN</td>
          <td><div id="bond-summary"></div></td>
        </tr>
        <tr>
          <td>Why this name?</td>
          <td><div id="explanation"></div></td>
        </tr>
      </table>
    </div>
  </div>

  <script>
    // ======== ELEMENT DATA (first 20, HS core) ========
    const elements = [
      {Z:1,  row:1, col:1,  symbol:"H",  name:"Hydrogen",  EN:2.20, category:"nonmetal",  isMetal:false, isPoly:false, commonIonCharge:1},
      {Z:2,  row:1, col:18, symbol:"He", name:"Helium",    EN:null, category:"nonmetal",  isMetal:false, isPoly:false},
      {Z:3,  row:2, col:1,  symbol:"Li", name:"Lithium",   EN:0.98, category:"metal",     isMetal:true,  isPoly:false, commonIonCharge:1},
      {Z:4,  row:2, col:2,  symbol:"Be", name:"Beryllium", EN:1.57, category:"metal",     isMetal:true,  isPoly:false, commonIonCharge:2},
      {Z:5,  row:2, col:13, symbol:"B",  name:"Boron",     EN:2.04, category:"metalloid", isMetal:false, isPoly:false},
      {Z:6,  row:2, col:14, symbol:"C",  name:"Carbon",    EN:2.55, category:"nonmetal",  isMetal:false, isPoly:false},
      {Z:7,  row:2, col:15, symbol:"N",  name:"Nitrogen",  EN:3.04, category:"nonmetal",  isMetal:false, isPoly:false, commonIonCharge:-3},
      {Z:8,  row:2, col:16, symbol:"O",  name:"Oxygen",    EN:3.44, category:"nonmetal",  isMetal:false, isPoly:false, commonIonCharge:-2},
      {Z:9,  row:2, col:17, symbol:"F",  name:"Fluorine",  EN:3.98, category:"nonmetal",  isMetal:false, isPoly:false, commonIonCharge:-1},
      {Z:10, row:2, col:18, symbol:"Ne", name:"Neon",      EN:null, category:"nonmetal",  isMetal:false, isPoly:false},
      {Z:11, row:3, col:1,  symbol:"Na", name:"Sodium",    EN:0.93, category:"metal",     isMetal:true,  isPoly:false, commonIonCharge:1},
      {Z:12, row:3, col:2,  symbol:"Mg", name:"Magnesium", EN:1.31, category:"metal",     isMetal:true,  isPoly:false, commonIonCharge:2},
      {Z:13, row:3, col:13, symbol:"Al", name:"Aluminum",  EN:1.61, category:"metal",     isMetal:true,  isPoly:false, commonIonCharge:3},
      {Z:14, row:3, col:14, symbol:"Si", name:"Silicon",   EN:1.90, category:"metalloid", isMetal:false, isPoly:false},
      {Z:15, row:3, col:15, symbol:"P",  name:"Phosphorus",EN:2.19, category:"nonmetal",  isMetal:false, isPoly:false, commonIonCharge:-3},
      {Z:16, row:3, col:16, symbol:"S",  name:"Sulfur",    EN:2.58, category:"nonmetal",  isMetal:false, isPoly:false, commonIonCharge:-2},
      {Z:17, row:3, col:17, symbol:"Cl", name:"Chlorine",  EN:3.16, category:"nonmetal",  isMetal:false, isPoly:false, commonIonCharge:-1},
      {Z:18, row:3, col:18, symbol:"Ar", name:"Argon",     EN:null, category:"nonmetal",  isMetal:false, isPoly:false},
      {Z:19, row:4, col:1,  symbol:"K",  name:"Potassium", EN:0.82, category:"metal",     isMetal:true,  isPoly:false, commonIonCharge:1},
      {Z:20, row:4, col:2,  symbol:"Ca", name:"Calcium",   EN:1.00, category:"metal",     isMetal:true,  isPoly:false, commonIonCharge:2}
    ];

    // ======== POLYATOMIC IONS (HS core) ========
    const polyIons = [
      // Cations
      {id:"NH4", symbol:"NH₄⁺", formula:"NH4", name:"ammonium", charge:+1, isMetal:false, isPoly:true},
      // Anions
      {id:"OH",  symbol:"OH⁻",  formula:"OH",  name:"hydroxide", charge:-1, isMetal:false, isPoly:true},
      {id:"NO3", symbol:"NO₃⁻", formula:"NO3", name:"nitrate",   charge:-1, isMetal:false, isPoly:true},
      {id:"NO2", symbol:"NO₂⁻", formula:"NO2", name:"nitrite",   charge:-1, isMetal:false, isPoly:true},
      {id:"SO4", symbol:"SO₄²⁻",formula:"SO4", name:"sulfate",   charge:-2, isMetal:false, isPoly:true},
      {id:"SO3", symbol:"SO₃²⁻",formula:"SO3", name:"sulfite",   charge:-2, isMetal:false, isPoly:true},
      {id:"CO3", symbol:"CO₃²⁻",formula:"CO3", name:"carbonate", charge:-2, isMetal:false, isPoly:true},
      {id:"HCO3",symbol:"HCO₃⁻",formula:"HCO3",name:"hydrogen carbonate", charge:-1, isMetal:false, isPoly:true},
      {id:"PO4", symbol:"PO₄³⁻",formula:"PO4", name:"phosphate", charge:-3, isMetal:false, isPoly:true},
      {id:"C2H3O2",symbol:"C₂H₃O₂⁻", formula:"C2H3O2", name:"acetate", charge:-1, isMetal:false, isPoly:true},
      {id:"CN",  symbol:"CN⁻",  formula:"CN",  name:"cyanide",   charge:-1, isMetal:false, isPoly:true},
      {id:"ClO3",symbol:"ClO₃⁻",formula:"ClO3", name:"chlorate", charge:-1, isMetal:false, isPoly:true}
    ];

    const tableContainer = document.getElementById("periodic-table");
    const polyListContainer = document.getElementById("poly-list");

    // ======== BUILD PERIODIC TABLE ========
    function buildPeriodicTable() {
      const maxRows = 7;
      const maxCols = 18;
      const map = {};
      elements.forEach(e => { map[`${e.row}-${e.col}`] = e; });

      for (let r = 1; r <= maxRows; r++) {
        for (let c = 1; c <= maxCols; c++) {
          const key = `${r}-${c}`;
          const cell = document.createElement("div");
          cell.style.gridRow = r;
          cell.style.gridColumn = c;
          if (map[key]) {
            const el = map[key];
            cell.classList.add("element");
            if (el.category === "metal") cell.classList.add("metal");
            else if (el.category === "nonmetal") cell.classList.add("nonmetal");
            else cell.classList.add("metalloid");
            cell.dataset.symbol = el.symbol;
            cell.title = `${el.name} (Z=${el.Z}) EN=${el.EN ?? "n/a"}`;
            cell.innerHTML = `<div>${el.symbol}</div><div style="font-size:9px;">${el.Z}</div>`;
            cell.onclick = () => handleElementClick(el.symbol);
          } else {
            cell.classList.add("element", "inactive");
            cell.innerHTML = "";
          }
          tableContainer.appendChild(cell);
        }
      }
    }

    // ======== BUILD POLY LIST ========
    function buildPolyList() {
      polyIons.forEach(pi => {
        const btn = document.createElement("div");
        btn.classList.add("poly-btn");
        btn.textContent = `${pi.symbol} (${pi.name})`;
        btn.title = `${pi.name}, charge ${pi.charge > 0 ? "+" + pi.charge : pi.charge}`;
        btn.onclick = () => handlePolyClick(pi.id);
        polyListContainer.appendChild(btn);
      });
    }

    // ======== STATE ========
    let slot1 = null; // { kind: 'element'|'poly', data: {} }
    let slot2 = null;

    function getActiveSlot() {
      const radios = document.getElementsByName("activeSlot");
      for (const r of radios) if (r.checked) return parseInt(r.value, 10);
      return 1;
    }

    function handleElementClick(symbol) {
      const el = elements.find(e => e.symbol === symbol);
      if (!el) return;
      const active = getActiveSlot();
      const wrapped = { kind:"element", data: el };

      if (active === 1) {
        slot1 = wrapped;
        document.getElementById("slot1-symbol").textContent = el.symbol;
        document.getElementById("slot1-name").textContent = el.name;
      } else {
        slot2 = wrapped;
        document.getElementById("slot2-symbol").textContent = el.symbol;
        document.getElementById("slot2-name").textContent = el.name;
      }
      refreshSelectionHighlight();
      updateAll();
    }

    function handlePolyClick(id) {
      const pi = polyIons.find(p => p.id === id);
      if (!pi) return;
      const active = getActiveSlot();
      const wrapped = { kind:"poly", data: pi };

      if (active === 1) {
        slot1 = wrapped;
        document.getElementById("slot1-symbol").textContent = pi.symbol;
        document.getElementById("slot1-name").textContent = pi.name + " (polyatomic ion)";
      } else {
        slot2 = wrapped;
        document.getElementById("slot2-symbol").textContent = pi.symbol;
        document.getElementById("slot2-name").textContent = pi.name + " (polyatomic ion)";
      }
      refreshSelectionHighlight();
      updateAll();
    }

    function clearSlot(i) {
      if (i === 1) {
        slot1 = null;
        document.getElementById("slot1-symbol").textContent = "–";
        document.getElementById("slot1-name").textContent = "No species";
      } else {
        slot2 = null;
        document.getElementById("slot2-symbol").textContent = "–";
        document.getElementById("slot2-name").textContent = "No species";
      }
      refreshSelectionHighlight();
      updateAll();
    }

    function swapSlots() {
      const tmp = slot1;
      slot1 = slot2;
      slot2 = tmp;
      const c1 = document.getElementById("slot1-count");
      const c2 = document.getElementById("slot2-count");
      const tmpVal = c1.value;
      c1.value = c2.value;
      c2.value = tmpVal;

      // Update display labels
      function renderSlot(slot, symId, nameId) {
        if (!slot) {
          document.getElementById(symId).textContent = "–";
          document.getElementById(nameId).textContent = "No species";
        } else if (slot.kind === "element") {
          document.getElementById(symId).textContent = slot.data.symbol;
          document.getElementById(nameId).textContent = slot.data.name;
        } else {
          document.getElementById(symId).textContent = slot.data.symbol;
          document.getElementById(nameId).textContent = slot.data.name + " (polyatomic ion)";
        }
      }
      renderSlot(slot1, "slot1-symbol", "slot1-name");
      renderSlot(slot2, "slot2-symbol", "slot2-name");

      refreshSelectionHighlight();
      updateAll();
    }

    function refreshSelectionHighlight() {
      document.querySelectorAll(".element").forEach(cell => cell.classList.remove("selected"));
      const selectedSymbols = [];
      if (slot1 && slot1.kind === "element") selectedSymbols.push(slot1.data.symbol);
      if (slot2 && slot2.kind === "element") selectedSymbols.push(slot2.data.symbol);
      document.querySelectorAll(".element").forEach(cell => {
        if (selectedSymbols.includes(cell.dataset.symbol)) {
          cell.classList.add("selected");
        }
      });
    }

    // ======== HELPERS ========
    const prefixes = {
      1: "mono",
      2: "di",
      3: "tri",
      4: "tetra",
      5: "penta",
      6: "hexa",
      7: "hepta",
      8: "octa",
      9: "nona",
      10:"deca"
    };

    function anionStem(name) {
      name = name.toLowerCase();
      if (name.endsWith("ine")) return name.slice(0, -3) + "id";
      if (name.endsWith("gen")) return name.slice(0, -3) + "id";
      if (name.endsWith("ur")) return name + "id";
      if (name.endsWith("orus")) return name.slice(0, -4) + "phid";
      if (name.endsWith("on")) return name.slice(0, -2) + "id";
      return name + "id";
    }

    function cap(str) {
      if (!str) return str;
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function gcd(a, b) {
      if (!b) return a;
      return gcd(b, a % b);
    }

    function classifyBond(en1, en2) {
      if (en1 == null || en2 == null) return {delta:null, type:"EN missing"};
      const d = Math.abs(en1 - en2);
      let t;
      if (d > 1.7) t = "Ionic";
      else if (d >= 0.4) t = "Polar covalent";
      else t = "Non-polar covalent";
      return {delta:d, type:t};
    }

    function subscript(n) {
      return n === 1 ? "" : n.toString();
    }

    function renderSpeciesFormula(slot, count) {
      if (!slot) return "";
      if (slot.kind === "element") {
        return slot.data.symbol + subscript(count);
      } else {
        // polyatomic: parentheses if count > 1
        if (count === 1) return slot.data.formula;
        return "(" + slot.data.formula + ")" + subscript(count);
      }
    }

    // ======== MAIN UPDATE ========
    function updateAll() {
      const formulaDisplay = document.getElementById("formula-display");
      const nameDisplay = document.getElementById("name-display");
      const bondSummary = document.getElementById("bond-summary");
      const explanation = document.getElementById("explanation");

      const n1 = parseInt(document.getElementById("slot1-count").value, 10) || 1;
      const n2 = parseInt(document.getElementById("slot2-count").value, 10) || 1;

      if (!slot1 || !slot2) {
        formulaDisplay.textContent = "–";
        nameDisplay.textContent = "–";
        bondSummary.textContent = "Select species in both Slot 1 and Slot 2.";
        explanation.textContent = "";
        return;
      }

      const s1 = slot1;
      const s2 = slot2;

      // Determine if ionic or covalent overall
      const anyPoly = (s1.kind === "poly" || s2.kind === "poly");
      const s1IsMetal = (s1.kind === "element" && s1.data.isMetal);
      const s2IsMetal = (s2.kind === "element" && s2.data.isMetal);
      const bothElements = (s1.kind === "element" && s2.kind === "element");
      const ionicByType = anyPoly || (s1IsMetal !== s2IsMetal);

      let formula = "";
      let compoundName = "";
      let modeLabel = "";
      let explainText = "";

      if (ionicByType) {
        // IONIC NAMING
        modeLabel = "[Ionic: contains metal and/or polyatomic ion]";
        // Identify positive "cation-like" and negative "anion-like"
        let cationSlot, anionSlot;
        let cCharge, aCharge;

        if (anyPoly) {
          // If poly is positive, it's cation; if negative, it's anion.
          // Otherwise, use metal as cation.
          function chargeOf(slot) {
            if (slot.kind === "poly") return slot.data.charge;
            if (slot.kind === "element" && typeof slot.data.commonIonCharge === "number") {
              return slot.data.commonIonCharge;
            }
            return 0;
          }
          const q1 = chargeOf(s1);
          const q2 = chargeOf(s2);

          if (q1 > 0) { cationSlot = s1; cCharge = q1; }
          if (q2 > 0 && (!cationSlot)) { cationSlot = s2; cCharge = q2; }

          if (q1 < 0) { anionSlot = s1; aCharge = q1; }
          if (q2 < 0 && (!anionSlot)) { anionSlot = s2; aCharge = q2; }

          // fallback if something missing: treat metal as cation
          if (!cationSlot || !anionSlot) {
            if (s1IsMetal) { cationSlot = s1; anionSlot = s2; cCharge = s1.data.commonIonCharge ?? +1; aCharge = -1; }
            else if (s2IsMetal) { cationSlot = s2; anionSlot = s1; cCharge = s2.data.commonIonCharge ?? +1; aCharge = -1; }
            else { cationSlot = s1; anionSlot = s2; cCharge = +1; aCharge = -1; }
          }
        } else {
          // no polyatomic, but metal + nonmetal
          const cationElement = s1IsMetal ? s1 : s2;
          const anionElement = s1IsMetal ? s2 : s1;
          cationSlot = cationElement;
          anionSlot = anionElement;
          cCharge = cationElement.data.commonIonCharge ?? +1;
          aCharge = anionElement.data.commonIonCharge ?? -1;
        }

        const a = Math.abs(cCharge);
        const b = Math.abs(aCharge);
        const g = gcd(a, b);
        const nCation = b / g;
        const nAnion = a / g;

        // Build formula with parentheses where needed
        const cationFirst = (cationSlot === s1);
        const cSym = (cationSlot.kind === "element") ? cationSlot.data.symbol : cationSlot.data.formula;
        const aSym = (anionSlot.kind === "element") ? anionSlot.data.symbol : anionSlot.data.formula;

        function renderIon(slot, n) {
          if (slot.kind === "element") {
            return slot.data.symbol + subscript(n);
          } else {
            if (n === 1) return slot.data.formula;
            return "(" + slot.data.formula + ")" + subscript(n);
          }
        }

        if (cationFirst) {
          formula = renderIon(cationSlot, nCation) + renderIon(anionSlot, nAnion);
        } else {
          formula = renderIon(anionSlot, nAnion) + renderIon(cationSlot, nCation);
        }

        // Name
        let cName, aName;
        if (cationSlot.kind === "element") {
          cName = cap(cationSlot.data.name.toLowerCase());
        } else {
          cName = cationSlot.data.name; // ammonium
        }

        if (anionSlot.kind === "element") {
          const stem = anionStem(anionSlot.data.name);
          aName = stem + "e"; // oxide, chloride, etc.
        } else {
          aName = anionSlot.data.name; // sulfate, nitrate, etc.
        }

        compoundName = `${cName} ${aName}`;

        explainText =
          "Ionic naming:\n" +
          "- At least one species is a metal or a polyatomic ion.\n" +
          "- Charges are balanced by choosing subscripts so total positive and negative charge cancel.\n" +
          "- Cation name is written first.\n" +
          "- Anion is written second; monatomic anions use “-ide”, polyatomic ions keep their name (sulfate, nitrate, etc.).";
      } else if (bothElements) {
        // COVALENT NAMING (two elements, both nonmetals/metalloids)
        modeLabel = "[Covalent: two nonmetals / metalloid + nonmetal]";
        const e1 = s1.data;
        const e2 = s2.data;

        formula = e1.symbol + subscript(n1) + e2.symbol + subscript(n2);

        let firstName = e1.name.toLowerCase();
        if (n1 > 1 && prefixes[n1]) {
          firstName = prefixes[n1] + " " + firstName;
        }

        const stem = anionStem(e2.name);
        let secondName = stem + "e";
        if (prefixes[n2]) {
          secondName = prefixes[n2] + " " + secondName;
        }

        compoundName = `${cap(firstName)} ${secondName}`;

        explainText =
          "Covalent naming:\n" +
          "- Two nonmetals share electrons.\n" +
          "- Subscripts n₁ and n₂ come from the number of atoms of each element.\n" +
          "- Prefixes (mono-, di-, tri-, etc.) show the count.\n" +
          "- The first element usually drops “mono-” when n₁ = 1.\n" +
          "- The second element name ends in “-ide”.";
      } else {
        // Fallback: rare cases (e.g., metalloid + something odd)
        modeLabel = "[Covalent-style naming]";
        const e1 = (s1.kind === "element") ? s1.data : null;
        const e2 = (s2.kind === "element") ? s2.data : null;
        if (e1 && e2) {
          formula = e1.symbol + subscript(n1) + e2.symbol + subscript(n2);
          let firstName = e1.name.toLowerCase();
          if (n1 > 1 && prefixes[n1]) firstName = prefixes[n1] + " " + firstName;
          const stem = anionStem(e2.name);
          let secondName = stem + "e";
          if (prefixes[n2]) secondName = prefixes[n2] + " " + secondName;
          compoundName = `${cap(firstName)} ${secondName}`;
        } else {
          formula = renderSpeciesFormula(s1, n1) + renderSpeciesFormula(s2, n2);
          compoundName = "(naming not defined for this combination)";
        }
        explainText =
          "This combination does not fit the simple metal/nonmetal or polyatomic patterns.\n" +
          "Treat it as a covalent-style pair: use prefixes for counts and “-ide” for the second element when appropriate.";
      }

      // Bond summary: ΔEN only when both are plain elements
      let bondText = "";
      if (bothElements) {
        const info = classifyBond(s1.data.EN, s2.data.EN);
        if (info.delta == null) {
          bondText = `${modeLabel} EN information incomplete for one or both elements.`;
        } else {
          bondText =
            `${modeLabel}\n` +
            `ΔEN = |EN(${s1.data.symbol}) − EN(${s2.data.symbol})| = ` +
            `|${s1.data.EN.toFixed(2)} − ${s2.data.EN.toFixed(2)}| = ${info.delta.toFixed(2)} → ${info.type}.`;
        }
      } else {
        bondText =
          modeLabel + "\n" +
          "At least one species is polyatomic, so the compound is treated as ionic (ions held together by electrostatic attraction).";
      }

      formulaDisplay.textContent = formula;
      nameDisplay.textContent = compoundName;
      bondSummary.textContent = bondText;
      explanation.textContent = explainText;
    }

    // ======== INIT ========
    buildPeriodicTable();
    buildPolyList();
    updateAll();
  </script>
</body>
</html>
